# Lab 05\. Черги повідомлень

## Завдання

1. Проаналізуйте один із наведених нижче варіантів коду і вкажіть на можливі помилки.  
2. Створіть модульні тести (pytest), які покажуть наявність помилок. Один тест має перевіряти одну помилку  
3. Проаналізуйте важливість знайдених помилок.  
4. Виправте помилки.  
5. За допомогою тестів покажіть, що помилки виправлено.

Результатом роботи є jupyter notebook в  [Google Colab](https://colab.google/) або репозиторій на github, який містить завдання, початковий варіант коду із тестами, виправлений варіант коду із тестами, пояснення виправлень.

Рекомендується використовувати одну з LLM ([https://chatgpt.com/](https://chatgpt.com/) , [https://gemini.google.com/](https://gemini.google.com/) , [https://chat.deepseek.com/](https://chat.deepseek.com/) або іншу) для прискорення роботи. 

## Хід роботи

1. **Ознайомлення з теорією:** Повторити основи роботи черг повідомлень та інструментів типу Apache Kafka. Звернути увагу на типові проблеми, наведені у чеклісті: некоректні параметри продюсерів і споживачів, відсутність ідемпотентності, неправильний коміт офсетів, відсутність обробки винятків, дисбаланс між кількістю партицій та споживачів, блокуюча обробка повідомлень.

2. **Вибір коду для аналізу:** Обрати один із наданих варіантів програмного коду з використанням черг повідомлень. Зосередитися на класах продюсера, споживача або конфігурації кластера.

3. **Пошук і аналіз помилок:** Перевірити код за контрольними пунктами з чекліста:  
    – чи правильно налаштована кількість партицій і replication factor;  
    – чи використовуються параметри `enable.idempotence`, `acks=all`, `enable.auto.commit=false`;  
    – чи обробляються винятки при відправленні й отриманні;  
    – чи реалізовано commit після успішної обробки;  
    – чи не блокується метод `poll()` важкою логікою;  
    – чи є підтримка DLQ (dead-letter queue);  
    – чи враховано безпеку (TLS, ACL).

4. **Формулювання переліку помилок:** Створити список проблем, кожну описати: де вона у коді, чому є помилкою, які наслідки (втрата повідомлень, дублікати, зависання, небезпечна поведінка при відмові брокера).

5. **Створення модульних тестів:** Для кожної знайденої помилки створити окремий тест. Один тест \= одна помилка. Приклади тестів:  
    – тест, що демонструє дублікати повідомлень через відсутність ідемпотентності;  
    – тест, що виявляє втрату повідомлень при автоматичному коміті;  
    – тест, що перевіряє неправильну реакцію при відмові брокера.

6. **Аналіз важливості помилок:** Класифікувати помилки за критичністю:  
    – критичні (призводять до втрати або дублювання даних, порушення узгодженості);  
    – середньої важливості (знижують продуктивність чи стійкість до збоїв);  
    – менш значущі (некоректні параметри оптимізації).

7. **Виправлення коду:** Внести виправлення відповідно до найкращих практик:  
    – увімкнути ідемпотентність та `acks=all`;  
    – вимкнути авто-коміт офсетів і реалізувати явний commit після успішної обробки;  
    – додати обробку винятків і логування;  
    – налаштувати параметри `batch_size`, `linger_ms`, `compression.type`;  
    – передбачити DLQ;  
    – перевірити відповідність параметрів безпеки.

8. **Перевірка виправленого коду тестами:** Запустити підготовлені тести на новій версії програми та переконатися, що вони проходять.

9. **Оформлення результатів:**  Підготувати Jupyter Notebook у Google Colab або репозиторій на GitHub, який містить:  
    – завдання;  
    – початковий код із тестами, що показують помилки;  
    – виправлений код із тестами, що підтверджують коректність;  
    – пояснення знайдених помилок і внесених змін.

10. **Фінальний аналіз:** У висновках описати, які помилки було знайдено, які з них найкритичніші, як вони впливають на відмовостійкість і продуктивність системи, та як виправлення гарантують правильну роботу черг повідомлень.

